@inproceedings{Szegedy2016,
abstract = {Convolutional networks are at the core of most state of-the-art computer vision solutions for a wide variety of tasks. Since 2014 very deep convolutional networks started to become mainstream, yielding substantial gains in various benchmarks. Although increased model size and computational cost tend to translate to immediate quality gains for most tasks (as long as enough labeled data is provided for training), computational efficiency and low parameter count are still enabling factors for various use cases such as mobile vision and big-data scenarios. Here we are exploring ways to scale up networks in ways that aim at utilizing the added computation as efficiently as possible by suitably factorized convolutions and aggressive regularization. We benchmark our methods on the ILSVRC 2012 classification challenge validation set demonstrate substantial gains over the state of the art: 21:2{\%} top-1 and 5:6{\%} top-5 error for single frame evaluation using a network with a computational cost of 5 billion multiply-adds per inference and with using less than 25 million parameters. With an ensemble of 4 models and multi-crop evaluation, we report 3:5{\%} top-5 error and 17:3{\%} top-1 error on the validation set and 3:6{\%} top-5 error on the official test set.},
archivePrefix = {arXiv},
arxivId = {1512.00567},
author = {Szegedy, Christian and Vanhoucke, Vincent and Ioffe, Sergey and Shlens, Jon and Wojna, Zbigniew},
booktitle = {Proceedings of the IEEE Computer Society Conference on Computer Vision and Pattern Recognition},
doi = {10.1109/CVPR.2016.308},
eprint = {1512.00567},
file = {:home/mhizzani/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Szegedy et al. - 2016 - Rethinking the Inception Architecture for Computer Vision.pdf:pdf},
isbn = {9781467388504},
issn = {10636919},
pages = {2818--2826},
publisher = {IEEE Computer Society},
title = {{Rethinking the Inception Architecture for Computer Vision}},
volume = {2016-December},
year = {2016}
}
@misc{JuliaMehtods,
title = {{Julia Methods}},
url = {https://docs.julialang.org/en/v1/manual/methods/{\#}Defining-Methods-1}
}
@misc{Keras,
title = {{Home - Keras Documentation}},
url = {https://keras.io/},
urldate = {2020-04-21}
}
@misc{WikiMultipleDispatch,
title = {{Multiple dispatch - Wikipedia}},
url = {https://en.wikipedia.org/wiki/Multiple{\_}dispatch},
urldate = {2020-04-19}
}
@article{Bezanson2017,
abstract = {Bridging cultures that have often been distant, Julia combines expertise from the diverse helds of computer science and computational science to create a new approach to numerical computing. Julia is designed to be easy and fast and questions notions generally held to be "laws of nature" by practitioners of numerical computing: 1. High-level dynamic programs have to be slow. 2. One must prototype in one language and then rewrite in another language for speed or deployment. 3. There are parts of a system appropriate for the programmer, and other parts that are best left untouched as they have been built by the experts. We introduce the Julia programming language and its design-a dance between specialization and abstraction. Specialization allows for custom treatment. Multiple dispatch, a technique from computer science, picks the right algorithm for the right circumstance. Abstraction, which is what good computation is really about, recognizes what remains the same after differences are stripped away. Abstractions in mathematics are captured as code through another technique from computer science, generic programming. Julia shows that one can achieve machine performance without sacrificing human convenience.},
archivePrefix = {arXiv},
arxivId = {1411.1607},
author = {Bezanson, Jeff and Edelman, Alan and Karpinski, Stefan and Shah, Viral B.},
doi = {10.1137/141000671},
eprint = {1411.1607},
issn = {0036-1445},
journal = {SIAM Review},
keywords = {Julia,Numerical,Parallel,Scientific computing},
month = {feb},
number = {1},
pages = {65--98},
publisher = {Society for Industrial and Applied Mathematics Publications},
title = {{Julia: A fresh approach to numerical computing}},
volume = {59},
year = {2017}
}
@misc{Julia,
title = {{The Julia Language}},
url = {https://julialang.org/},
urldate = {2020-04-19}
}
@article{Lee1977,
abstract = {This correspondence introduces a new numbersystem, called the Focus number system system which “focuses” on available resolution near zero much like an operational amplifier “focuses” on tiny deviations near virtual ground. This number system is supported by algorithms providing addition, multiplication, and higher order functions in a bare microcomputer at speeds rivaling those of existing integer arithmetic [1]–[3] performed with a costly arithmetic unit. {\textcopyright} 1977, IEEE. All rights reserved.},
author = {Lee, Samuel C. and Edgar, Albert D.},
doi = {10.1109/TC.1977.1674770},
issn = {0018-9340},
journal = {IEEE Transactions on Computers},
keywords = {Control systems,Logarithmic number system,Variable resolution encoding},
number = {11},
pages = {1167--1170},
title = {{The Focus Number System}},
volume = {C-26},
year = {1977}
}
@article{Alexopoulos1975,
abstract = {A signed logarithmic number system, which is capable of representing negative as well as positive numbers is described. A number is represented in the sign/logarithm number system by a sign bit and the logarithm of the absolute value of the number (scaled to avoid negative logarithms). Algorithms have been developed to perform all four of the basic arithmetic operations (i.e., addition, subtraction, multiplication, and division). It appears that such an arithmetic unit can be somewhat faster than a conventional arithmetic unit of comparable complexity. This system is intended for use in implementing special purpose computers, where constant relative accuracy is not objectionable. Copyright {\textcopyright} 1975 by The Institute of Electrical and Electronics Engineers, Inc.},
author = {Alexopoulos, Aristides G.},
doi = {10.1109/T-C.1975.224172},
issn = {0018-9340},
journal = {IEEE Transactions on Computers},
keywords = {Computer arithmetic units,logarithmic addition,logarithmic arithmetic,logarithmic subtraction,number systems},
number = {12},
pages = {1238--1242},
title = {{The Sign/Logarithm Number System}},
volume = {C-24},
year = {1975}
}
@article{Kingsbury1971,
abstract = {A method of computation is described in which all signals are encoded logarithmically, giving a great improvement in dynamic range compared with fixed-point linearly encoded arithmetic. Two ways of adding or subtracting logarithmically encoded numbers are suggested, together with a logarithmic digital-analogue convenor. {\textcopyright} 1971, The Institution of Electrical Engineers. All rights reserved.},
author = {Kingsbury, N. G. and Rayner, P. J.W.},
doi = {10.1049/el:19710039},
issn = {0013-5194},
journal = {Electronics Letters},
keywords = {Filtering and prediction theory},
number = {2},
pages = {56--58},
title = {{Digital filtering using logarithmic arithmetic}},
volume = {7},
year = {1971}
}
@article{Samimi2020,
abstract = {In this article, a technique, based on using Residue Number System (RNS) is suggested to improve the energy efficiency of Deep Neural Networks (DNNs). In the DNN architecture, which is fully RNS-based, only weights and the primary inputs in the main memory are in the binary number system (BNS). The architecture, which is called Res-DNN, offers a high energy saving while requiring higher bit count for data to handle the overflow compared to that of a BNS one. Scaling techniques in the processing elements are employed in the RNS-based computations to make the computation bit widths the same as the BNS bit width. In this architecture, the MAX pooling and ReLU activation function are implemented in the RNS format. To lower the memory usage and required memory bandwidth, we suggest a Huffman-based coding. Additionally, for accessing the weights stored in the main memory, to obtain further energy reduction, we propose a structural modification to the memory hierarchy where a lower level register file is added to the data path of these accesses. The effectiveness of the proposed architecture is evaluated under seven state-of-the-art DNNs with the datasets of ImageNet and CIFAR-10. The obtained results show that Res-DNN leads to 2.5 × lower energy for computations and an average of 30{\%} overall energy reduction compared to those of the binary counterpart.},
author = {Samimi, Nasim and Kamal, Mehdi and Afzali-Kusha, Ali and Pedram, Massoud},
doi = {10.1109/TCSI.2019.2951083},
issn = {1558-0806},
journal = {IEEE Transactions on Circuits and Systems I: Regular Papers},
keywords = {Residue number system,architecture,deep neural network,energy},
number = {2},
pages = {658--671},
publisher = {Institute of Electrical and Electronics Engineers Inc.},
title = {{Res-DNN: A residue number system-based DNN accelerator unit}},
volume = {67},
year = {2020}
}
@article{Gustafson2017,
abstract = {A new data type called a posit is designed as a direct drop-in replacement for IEEE Standard 754 floating-point numbers (floats). Unlike earlier forms of universal number (unum) arithmetic, posits do not require interval arithmetic or variable size operands; like floats, they round if an answer is inexact. However, they provide compelling advantages over floats, including larger dynamic range, higher accuracy, better closure, bitwise identical results across systems, simpler hardware, and simpler exception handling. Posits never overflow to infinity or underflow to zero, and "Nota- Number" (NaN) indicates an action instead of a bit pattern. A posit processing unit takes less circuitry than an IEEE float FPU. With lower power use and smaller silicon footprint, the posit operations per second (POPS) supported by a chip can be significantly higher than the FLOPS using similar hardware resources. GPU accelerators and Deep Learning processors, in particular, can do more per watt and per dollar with posits, yet deliver superior answer quality. A comprehensive series of benchmarks compares floats and posits for decimals of accuracy produced for a set precision. Low precision posits provide a better solution than "approximate computing" methods that try to tolerate decreased answer quality. High precision posits provide more correct decimals than floats of the same size; in some cases, a 32-bit posit may safely replace a 64-bit float. In other words, posits beat floats at their own game.},
author = {Gustafson, John L. and Yonemoto, Isaac},
doi = {10.14529/jsfi170206},
file = {:home/mhizzani/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/John L. Gustafson, Isaac Yonemoto - 2017 - Beating floating point at its own game Posit arithmetic.pdf:pdf},
issn = {2313-8734},
journal = {Supercomputing Frontiers and Innovations},
keywords = {Computer arithmetic,Energy-efficient computing,Floating point,LINPACK,Linear algebra,Neural networks,Posits,Unum computing,Valid arithmetic},
number = {2},
pages = {71--86},
publisher = {South Ural State University, Publishing Center},
title = {{Beating floating point at its own game: Posit arithmetic}},
volume = {4},
year = {2017}
}
@article{754,
isbn = {9781504459242},
journal = {IEEE Std 754-2019 (Revision of IEEE 754-2008)},
pages = {1--84},
publisher = {IEEE},
title = {{754-2019 - IEEE Standard for Floating-Point Arithmetic}},
year = {2019}
}
@inproceedings{Garner1959,
address = {New York, New York, USA},
author = {Garner, Harvey L.},
booktitle = {Papers presented at the the March 3-5, 1959, western joint computer conference on XX - IRE-AIEE-ACM '59 (Western)},
doi = {10.1145/1457838.1457864},
file = {:home/mhizzani/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Garner - 1959 - The residue number system.pdf:pdf},
pages = {146--153},
publisher = {ACM Press},
title = {{The residue number system}},
year = {1959}
}
@article{Miyashita2016,
abstract = {Recent advances in convolutional neural networks have considered model complexity and hardware efficiency to enable deployment onto embedded systems and mobile devices. For example, it is now well-known that the arithmetic operations of deep networks can be encoded down to 8-bit fixed-point without significant deterioration in performance. However, further reduction in precision down to as low as 3-bit fixed-point results in significant losses in performance. In this paper we propose a new data representation that enables state-of-the-art networks to be encoded to 3 bits with negligible loss in classification performance. To perform this, we take advantage of the fact that the weights and activations in a trained network naturally have non-uniform distributions. Using non-uniform, base-2 logarithmic representation to encode weights, communicate activations, and perform dot-products enables networks to 1) achieve higher classification accuracies than fixed-point at the same resolution and 2) eliminate bulky digital multipliers. Finally, we propose an end-to-end training procedure that uses log representation at 5-bits, which achieves higher final test accuracy than linear at 5-bits.},
archivePrefix = {arXiv},
arxivId = {1603.01025},
author = {Miyashita, Daisuke and Lee, Edward H. and Murmann, Boris},
eprint = {1603.01025},
file = {:home/mhizzani/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Miyashita, Lee, Murmann - 2016 - Convolutional Neural Networks using Logarithmic Data Representation.pdf:pdf},
month = {mar},
title = {{Convolutional Neural Networks using Logarithmic Data Representation}},
url = {http://arxiv.org/abs/1603.01025},
year = {2016}
}
